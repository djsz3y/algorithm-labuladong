Day19.动态规划问题的两种穷举视角

# 零、前言

## 更新日志：

> 2024-4-24：总结了 零、前言 & 动态规划解题组合拳。

## 本文主要内容：

1. 复习**动态规划**相关问题的**一系列解题套路**，即：动态规划解题组合拳，
2. 着重讨论**动态规划穷举时不同视角**的问题，即：排列问题的两种视角。

# ⭐ 一、动态规划解题组合拳（概括前面 Day16~18 的动态规划打卡 & 本文主要内容：动态规划穷举时不同视角）

1. 算法问题的**本质**是「穷举」，动态规划问题也不例外，  
   必须想办法**穷举所有可能**的解，  
   然后从中**筛选出符合题目**要求的解。

2. 前提：动态规划问题的**穷举的过程**会出现**重叠子问题导致的冗余计算**，  
   ① 在第 16 天打卡中，有：如何一步一步把**暴力穷举解法**优化成**效率更高**的**动态规划解法**；  
   ② 详见原文：[动态规划核心套路框架](https://labuladong.online/algo/essential-technique/dynamic-programming-framework/)；  
   ③ 或者看之前的打卡文章：[Day16.动态规划详解](https://zhuanlan.zhihu.com/p/693628709)；

3. 前提：写出**暴力解**要依据**状态转移方程**，状态转移方程是动态规划的**解题核心**，**不容易**想出来。  
   ① 在第 17 天打卡中，有：思考状态转移方程的基本方法是**数学归纳法**，即：**明确 dp 函数或数组的定义**，然后**使用这个定义**，从**已知的「状态」中推导出未知的「状态」**；  
   ② 详见原文：[动态规划设计：数学归纳法](https://labuladong.online/algo/dynamic-programming/longest-increasing-subsequence/)；  
   ③ 或者看之前的打卡文章：[Day17.动态规划设计：最长递增子序列](https://zhuanlan.zhihu.com/p/694014221)；

4. 前提：高楼扔鸡蛋问题 中对 **dp 函数/数组的定义不见得是唯一**的，**不同的定义会导致状态转移方程发生变化**，  
   那么：解题效率有高低之分，所以应该**给 dp 函数尽可能想出更合适的定义**来解题。  
   ① 在第 18 天打卡中，有：明白「最优子结构」、如何看出是否存在重叠子问题、为什么 dp.length is n + 1 not n、为什么正着/倒着/斜着遍历 dp 数组；在其中，讲到了 高楼扔鸡蛋 的举例；  
   ② 详见 高楼扔鸡蛋问题 原文：[经典动态规划：高楼扔鸡蛋](https://labuladong.online/algo/dynamic-programming/egg-drop/)；  
   ② 详见打卡原文[最优子结构原理和 dp 数组遍历方向](https://labuladong.online/algo/dynamic-programming/faq-summary/)；  
   ③ 或者看之前的打卡文章：[Day18.动态规划系列答疑篇](https://zhuanlan.zhihu.com/p/694155643)；

5. 接下来，本文着重探讨：就算 **dp 函数/数组的定义相同**，如果你**使用不同的「视角」进行穷举**，**效率也不见得是相同的**。

6. 穷举「视角」的问题：[回溯算法穷举视角：子集划分问题](https://labuladong.online/algo/practice-in-action/partition-to-k-equal-sum-subsets/)；  
   讲了回溯算法中**不同的穷举视角导致的不同解法**，其实这种**视角的切换**在**动态规划**类型问题中**依然存在**。  
   前文对**排列的举例**非常**有助于你理解穷举视角**的问题，这里再简单提一下。

# ⭐ 二、排列问题的两种视角

## 2.1.回顾排列组合知识：

> 详见 [Day15.球盒模型：回溯算法的两种视角](https://zhuanlan.zhihu.com/p/693464466) 的 “一、暴力穷举思维方法：球盒模型【done】”  
> 以下：1、~7、都是以上链接中的内容，较详细，这里简单列出顺序大概浏览一下，回忆思路。

1、「排列」和「组合」的主要区别在于是否考虑顺序的差异。

2、计算公式

```math
P(n, k) = n!/(n - k)!
```

```math
C(n, k) = n!/k!(n - k)!
```

3、排列组合问题的各种变体都可以抽象成「球盒模型」

4、盒子的视角

```math
P(n, k) = nP(n - 1, k - 1)
```

5、球的视角

```math
P(n, k) = P(n - 1, k) + kP(n - 1, k - 1)
```

6、两种视角得到 两个不同递归式，解开，是阶乘形式：

```math
P(n, k)
= nP(n - 1, k - 1)
= P(n - 1, k) + kP(n - 1, k - 1)
= n!(n - k)!
```

7、有兴趣自行学习组合数学相关知识，解开递归式。

## 2.2.记住以上例子，下面会把 穷举视角的差异运用到动态规划

1. 以上只是纯数学的推导，`P(n, k)` 计算结果仅是数字，

2. 从数学上讲，以上两种穷举视角没差异。

3. 编程的角度，计算出所有排列结果，  
   ① 那么**两种穷举思路的代码**实现可能会产生**性能上的差异**，  
   ② 因为**有的穷举思路**难免会使用**额外的 for 循环拖慢效率**，  
   这也是后文 [回溯算法穷举视角：子集划分问题](https://labuladong.online/algo/practice-in-action/partition-to-k-equal-sum-subsets/) 主要探讨的。

4. 本文不讲回溯算法和排列组合，不过**记住这个例子**，待会会把这种**穷举视角的差异运用到动态规划**题目

# ⭐ 三、例题分析（115. 不同的子序列）

> [115. 不同的子序列](https://leetcode.cn/problems/distinct-subsequences/description/)

## 1.读懂题目

1. 输入字符串 s & 字符串 t，

2. 计算 s 子序列中， t 出现的次数。

3. 举例：  
   输入：s = "babgbag", t = "bag"  
   输出：5  
   解释：  
   如下所示, 有 5 种可以从 s 中得到 "bag" 的方案。  
   babgbag  
   babgbag  
   babgbag  
   babgbag  
   babgbag

4. 函数签名

```js
var numDistinct = function (s, t) {}
```

## ⭐⭐2.写出思路

### 2.1.理解题目：

1. 数一数 s 的子序列中有多少个 t，说白了就是**穷举**嘛，

2. 那么**首先想到**的就是能不能把**原问题分解成规模更小的子问题**，然后通过**子问题的答案推导出原问题的答案**。

### 2.2.首先，我们可以这样定义一个 dp 函数：

```js
var dp = function (s, i, t, j) {
  // s[i..] 的子序列中 t[j..] 出现的次数
}
```

1. 这道题对 **dp 函数的定义**很**简单直接**，题目让你**求出现次数**，那你就**定义函数返回值**为**出现次数**就可以。

2. 有了这个 dp 函数，题目想要的结果是 `dp(s, 0, t, 0)`，base case 也很容易写出来，解法框架如下：

```js
var numDistinct = function (s, t) {
  // 定义：s[i..] 的子序列中 t[j..] 出现的次数为 dp(s, i, t, j)
  const dp = function (s, i, t, j) {
    // base case 1
    if (j === t.length) {
      // t 已经全部匹配完成
      return 1
    }
    // base case 2
    if (s.length - i < t.length - j) {
      // s[i..] 比 t[j..] 还短，必然没有匹配的子序列
      return 0
    }

    // ...
  }

  return dp(s, 0, t, 0)
}
```

### 2.3.如何写出状态转移方程进行穷举

> 接下来，思考如何利用这个 **dp 函数将大问题分解成小问题**，即**如何写出状态转移方程进行穷举**。

1. 回顾 排列组合的「球盒模型」，这里很类似。
2. t 中的若干字符就好像若干盒子，s 中的若干字符就好像若干小球，你需要做的就是给**所有盒子都装一个小球**。
3. 所以这里就有**两种穷举思路**了，分别是站在 **t 的视角（盒子选择小球）和站在 s 的视角（小球选择盒子）**。

#### 1）视角一，站在 t 的角度进行穷举：

##### 【1】分析：原问题并转化

- 原问题：s[0..] 中 t[0..] 出现的次数
- 拆解：先看 t[0] 在 s[?] 的什么位置
- 假设：s[2]，s[6] 是字符 t[0]
- 原问题转化为：s[3..] 和 s[7..] 的所有子序列中计算 t[1..] 出现的次数。

##### 【2】写成数学形式，即状态转移方程（思路不难理解）：

```sql
-- 定义：s[i..] 的子序列中 t[j..] 出现的次数为 dp(s, i, t, j)
dp(s, i, t, j) = SUM( dp(s, k + 1, t, j + 1) where k >= i and s[k] == t[j] )
```

##### 【3】翻译成代码（思路不难理解）：

```js
// 定义：s[i..] 的子序列中 t[j..] 出现的次数为 dp(s, i, t, j)
function dp(s, i, t, j) {
  let res = 0
  // 在 s[i..] 中寻找 k，使得 s[k] == t[j]
  for (let k = i; k < s.length; k++) {
    if (s.charAt(k) == t.charAt(j)) {
      // s[k] === t[j]
      // 累加结果
      res += dp(s, k + 1, t, j + 1)
    }
  }
  return res
}
```

##### 【4】**加上备忘录**消除重叠子问题，最终解法如下：

```js
var numDistinct = function (s, t) {
  // 备忘录
  const memo = new Array(s.length)
    .fill()
    .map(() => new Array(t.length).fill(-1))

  const dp = function (i, j) {
    // base case 1
    if (j === t.length) {
      return 1
    }
    // base case 2
    if (s.length - i < t.length - j) {
      return 0
    }
    // 查备忘录防止冗余计算
    if (memo[i][j] !== -1) {
      return memo[i][j]
    }
    let res = 0
    // 执行状态转移方程
    // 在 s[i..] 中寻找 k，使得 s[k] == t[j]
    for (let k = i; k < s.length; k++) {
      if (s.charAt(k) === t.charAt(j)) {
        // 累加结果
        res += dp(k + 1, j + 1)
      }
    }
    // 存入备忘录
    memo[i][j] = res
    return res
  }

  return dp(0, 0)
}
```

##### 【5】估算算法的时间复杂度上界

> 此题解决了，效率不算很高，粗略估算算法的时间复杂度上界；

[1]其中：

1. M, N 分别代表 s, t 的长度，
2. 算法的「状态」就是 dp 函数参数 i, j 的组合：

```
  带备忘录的动态规划算法的时间复杂度
= 子问题的个数 x 函数本身的时间复杂度
= 「状态」的个数 x 函数本身的时间复杂度
= O(MN) * O(M)
= O(N * M^2)
```

[2]当然：

1. 因为 **for 循环的复杂度不总是 `O(M)`** 且**子问题个数肯定小于 `O(MN)`**，所以这是**复杂度的粗略上界**。

2. 不过根据前文 [算法时空复杂度使用指南](https://labuladong.online/algo/essential-technique/complexity-analysis/) 的描述，这个**上界还是说明这个算法的复杂度有些偏高**。

3. 主要**高在哪**里呢？  
   ① **对「状态」的穷举**已经有了 **memo 备忘录的优化**，所以 **`O(MN)` 的复杂度是必不可少**的，  
   ② **关键问题**出在 **dp 函数中的 for 循环**。

##### 【6】是否可以**优化掉 dp 函数中的 for 循环**呢？

- 可以的，这就需要**另一种穷举视角**来解决这个问题。

### 【todo】

#### 2）视角二，站在 s 的角度进行穷举：

## 3.代码实现

1. 见上文 [1）视角一，站在 t 的角度进行穷举：](#1视角一站在-t-的角度进行穷举)

2. 见上文 [2）视角二，站在 s 的角度进行穷举：](#2视角二站在-s-的角度进行穷举)

## 4.测试用例

```js

```

# 总结

Day19.动态规划问题的两种穷举视角

## 更新日志：

> 2024-4-24：总结了 零、前言 & 动态规划解题组合拳。

## 【收获 1】

【1】今天学习了 **动态规划问题的两种穷举视角** 技巧，

以后遇到 [115. 不同的子序列](https://leetcode.cn/problems/distinct-subsequences/description/) 类型的题目，

【2】我可以按照 以下 的标准化步骤思考：

[1]先 理解题目，看出穷举，
[2]然后 想到：能不能把**原问题分解成规模更小的子问题**，然后通过**子问题的答案推导出原问题的答案**。
[3]然后 定义 `dp` 函数：此题让求出现次数，那么就**定义函数返回值**为**出现次数**就可以。题目想要的结果是 `dp(s, 0, t, 0)`，base case 也很容易写出来。
[4]然后 写状态转移方程进行穷举：

> 思考如何利用 **dp 函数将大问题分解成小问题**

1. 先回顾：排列组合的「球盒模型」；
2. 再看此题：t 中若干字符就好像若干盒子，s 中若干字符就好像若干小球，所以就要做：所有盒子都装一个小球；
3. 所以想到：两种穷举思路：t 的视角（盒子选择小球）和 s 的视角（小球选择盒子），

[5]按照 **组合数学的思路**，分析 **上面第 3 步**，回顾一下 **排类组合问题的两种视角** 来看 **如何运用到动态规划**：

[5.1]上面第 3 步，也就是对应：

- 1）一盒必装一球 `P(n, k) = nP(n-1, k-1)`，以及
- 2）球的视角的两种思路  
  （因为 球多-并不是每一个球都被装进盒子里，  
  那么 两种思路-① first 球不装任意盒子，剩 n-1 球放 k 盒/  
  ② first 球装 k 盒中任一个，剩 n-1 球放 k-1 盒）  
  结合两种思路：`P(n, k) = P(n-1, k) + kP(n-1, k-1)`

[5.2]上面第 3 步，两种视角得到两个不同递归式，根据组合数学相关知识，解开结果都是：

- `1）一盒必装一球 = 2）球的视角的两种思路 = n!(n - k)!`

[6]t 的角度进行穷举：详见 [1）视角一，站在 t 的角度进行穷举：](#1视角一站在-t-的角度进行穷举)）

1. 分析原问题并举例的方式转化：详见 [【1】分析：原问题并转化](#1分析原问题并转化)
2. 写数学形式的状态转移方程：详见 [【2】写成数学形式，即状态转移方程（思路不难理解）：](#2写成数学形式即状态转移方程思路不难理解)
3. 翻译成代码：详见 [【3】翻译成代码（思路不难理解）：](#3翻译成代码思路不难理解)
4. 备忘录消除重叠子问题：详见 [【4】**加上备忘录**消除重叠子问题，最终解法如下：](#4加上备忘录消除重叠子问题最终解法如下)
5. 估算时间复杂度上界：详见 [【5】估算算法的时间复杂度上界](#5估算算法的时间复杂度上界)
6. 可以优化：详见 [【6】是否可以**优化掉 dp 函数中的 for 循环**呢？](#6是否可以优化掉-dp-函数中的-for-循环呢)

[7]s 的角度进行穷举【todo】

## 【收获 2】

今天输出了一篇打卡文章总结：

- [Day19.动态规划问题的两种穷举视角](https://github.com/djsz3y/algorithm-labuladong/blob/master/Day19.动态规划问题的两种穷举视角.md)

# 参考链接

- [LABULADONG 的算法网站](https://labuladong.online/algo/)
