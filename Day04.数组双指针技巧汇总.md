Day04.数组双指针技巧汇总

# 前言

## 1.处理数组、链表：

- 常用：双指针技巧；

## 2.双指针技巧分类

- 左右指针：两个指针**相向**而行或者**相背**而行；
- 快慢指针：两个指针**同向**而行，**一快一慢**；

## 3.双指针技巧用途

- 单链表：  
  -大部分是**快慢指针**（fast & slow）；  
  -比如：[双指针技巧秒杀七道链表题目](https://labuladong.online/algo/essential-technique/linked-list-skills-summary/)：  
   链表环判断，倒数第 K 个链表节点等问题；

- 数组：  
  **索引当作指针**，施展双指针技巧；

# 一、快慢指针技巧（单链表 LinkList）

> 比较常见的**快慢指针**技巧，是让你**原地修改**数组。

## 什么是原地修改？

【不是原地修改】：

1. new 一个 `int[]` 类型数组
2. 去重后元素，放进新数组
3. 返回新数组即可

【原地修改】：

1. 不允许 new 新数组，只能在原数组上操作，
2. 然后返回一个长度
3. 通过返回的长度 & 原始数组，得到去重后的元素有哪些。

## 为什么要原地修改？

- 由于数组已经排序，所以重复的元素一定连在一起，找出它们并不难。
- 但如果毎找到一个重复元素就立即原地删除它，由于数组中**删除元素涉及数据搬移**，整个**时间复杂度**是会达到 **O(N^2)**。

## ⭐ 使用快慢指针技巧，高效解决

【口诀：**慢后 快前，不重复 慢进**】：

1. 慢指针 slow 走在后面，
2. 快指针 fast 走在前面探路，
3. 找到一个不重复的元素就赋值给 slow 并让 slow 前进一步。

【保证了】：

- `nums[0..slow]` 都是无重复的元素，
- 当 fast 指针遍历完整个数组 nums 后，
- `nums[0..slow]` 就是整个数组去重之后的结果。

## [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/)

1.读懂题目：让在有序数组去重。

2.写出思路：明白原地修改的 What Why How。

（1）先判长度 0 直接 return 0；  
（2）声明快慢指针；  
（3）快到最后就结束，所以 while(fast < nums.length)；  
（4）一开始快慢重合，快慢值相等，让快++，所以 fast++；  
（5）这里思考一下，假如所有元素都相等，fast 直接走到最后了；  
（6）如果快慢值不相等（至少有两个值不相等，就要包含一些普遍情况了）：  
首先，**让慢++，是为了留下重复元素**；  
其次，**快值赋值给慢值，是为了**快值的不重复新元素往前移，**直接覆盖前面重复元素的位置**，也就**维护了 `nums[0..slow]` 无重复**；  
（7）循环完后，`slow + 1` 就是长度；

3.代码实现： removeDuplicates

```js
/*
 * 1.读懂题目：
 * 升序排列数组 nums
 * 原地删除重复元素
 * 返回删除后数组新长度
 * 保持元素相对顺序一致
 * --------------------------------------
 * // console.log(3 * Math.pow(10, 4));
 * let length = nums.length;
 * if (length <= 3 * Math.pow(10, 4) && length >= 0) {
 *   nums = Array.from(new Set(nums));
 *   return nums.length;
 * }
 * 看了labuladong的第26题题解，得知 ：
 * 我之前的做法是：不原地修改的题解。
 * 现在是原地修改的题解，才是对的。
 * --------------------------------------
 *
 * 2.写出思路：
 * 【不是原地修改】：new一个int类型数组-》把去重之后的元素放进新数组-》返回新数组。
 * 【原地修改】：不允许new新数组-》只能在原数组上操作，返回新长度-》通过返回的长度&原始数组=移除后的元素有哪些。
 * 【和 27.移除元素 一样的思路】：
 * 【快慢指针技巧】：快指针探路，慢指针在后，快指针每找到一个不等于val的元素就赋值给slow并让slow前进一步。
 * 这样保证了nums[0...slow]就是整个数组移除等于val的元素之后的结果。
 *
 * --------------------------------------
 * 【2024-4-7】
 * 1.读懂题目：让在有序数组去重。
 * 2.写出思路：明白原地修改的 What Why How。
 * （1）先判长度 0 直接 return 0；
 * （2）声明快慢指针；
 * （3）快到最后就结束，所以 while(fast < nums.length)；
 * （4）一开始快慢重合，快慢值相等，让快++，所以 fast++；
 * （5）这里思考一下，假如所有元素都相等，fast 直接走到最后了；
 * （6）如果快慢值不相等（至少有两个值不相等，就要包含一些普遍情况了）：
 * 首先，**让慢++，是为了留下重复元素**；
 * 其次，**快值赋值给慢值，是为了**快值的不重复新元素往前移，**直接覆盖前面重复元素的位置**，也就**维护了 `nums[0..slow]` 无重复**；
 * （7）循环完后，`slow + 1` 就是长度；
 *
 * 3.代码实现： removeDuplicates
 *
 * 4.测试用例：
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function (nums) {
  // 先判长度
  if (nums.length == 0) return 0
  // 快慢指针
  let slow = 0,
    fast = 0
  // fast 快到最后了，就结束了
  while (fast < nums.length) {
    // 判断快慢指针 位置值：
    //    快慢值 不相等，直接 慢++，快针值给了慢针值 & 之后，让快+1，去找快慢值不同的位置；
    //    快慢值 相等，直接 快++，去找快慢值不同的位置。
    if (nums[fast] !== nums[slow]) {
      slow++
      // 维护 nums[0..slow] 无重复
      nums[slow] = nums[fast]
    }
    fast++
  }
  // console.log(fast,slow)
  // 长度为索引+1
  return slow + 1
}
// let nums = [1, 1, 2];
// let res = removeDuplicates(nums);
// let nums2 = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4];
// let res2 = removeDuplicates(nums2);
// console.log(res, nums, res2, nums2);
```

## [83. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/)

有序的单链表，如何去重？

- 和数组去重几乎一样，
- 唯一的区别是：把数组赋值操作变成操作指针而已，

## [27. 移除元素](https://leetcode.cn/problems/remove-element/description/)

1.读懂题目：

- 数组 nums，
- 值 val，
- 原地移除 nums 里等于 val 的值，并返回移除后数组的新长度。
- 注意：不能使用额外数组空间，必须 o(1)额外空间并原地修改输入数组。
- 元素顺序可以改变，不需要考虑数组中超出新长度后面的元素。

  2.写出思路：

- 【不是原地修改】：new 一个 int 类型数组-》把去重之后的元素放进新数组-》返回新数组。
- 【原地修改】：不允许 new 新数组-》只能在原数组上操作，返回新长度-》通过返回的长度&原始数组=移除后的元素有哪些。
- 【和 26.删除有序数组中的重复项 一样的思路】：
- 【快慢指针技巧】：快指针探路，慢指针在后，快指针每找到一个不等于 val 的元素就赋值给 slow 并让 slow 前进一步。
- 这样保证了 nums[0...slow]就是整个数组移除等于 val 的元素之后的结果。

  3.代码实现： removeElement

## [283. 移动零](https://leetcode.cn/problems/move-zeroes/description/)

1.读懂题目：

2.写出思路：

3.代码实现：

4.测试用例：

# 二、左右指针的常用算法（数组 Array）

## 1、二分查找

> 只讨论最简单的二分算法，旨在突出它的双指针特性：

1.读懂题目：

2.写出思路：

3.代码实现：

4.测试用例：

## 2、两数之和

> [167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/)

1.读懂题目：

2.写出思路：

3.代码实现：

4.测试用例：

## 3、反转数组

> [344. 反转字符串](https://leetcode.cn/problems/reverse-string/description/)

1.读懂题目：

2.写出思路：

3.代码实现：

4.测试用例：

## 4、回文串判断

> [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/description/)

1.读懂题目：

2.写出思路：

3.代码实现：

4.测试用例：

# 总结

Day04.数组双指针技巧汇总

## 【收获 1】

今天学习了 **链表双指针技巧**，以后遇到 [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/) 类型的题目，我可以按照 **判断 nums.length 为 0 直接返回 0 -> 快慢指针 -> while 循环终止条件 fast 到最后 -> 最后返回 `slow + 1` ** 的标准化步骤思考。
其中第一步的作用是边缘条件，第二步的作用是快慢指针，第三步的作用是寻找 while 循环终止条件，第四步的作用是返回 nums.length。

## 【收获 2】

今天学习使用 **链表双指针技巧** 技巧解决了 LeetCode 的 26 题，我之前一直有一个**误区** 不知道原地修改，后来发现之前的做法是不原地修改的题解，今天发现原来做此类题目，**首先要明白**原地修改的 What Why How，然后根据这**7 步骤**来进行题解：
（1）先判长度 0 直接 return 0；  
（2）声明快慢指针；  
（3）快到最后就结束，所以 while(fast < nums.length)；  
（4）一开始快慢重合，快慢值相等，让快++，所以 fast++；  
（5）这里思考一下，假如所有元素都相等，fast 直接走到最后了；  
（6）如果快慢值不相等（至少有两个值不相等，就要包含一些普遍情况了）：  
首先，**让慢++，是为了留下重复元素**；  
其次，**快值赋值给慢值，是为了**快值的不重复新元素往前移，**直接覆盖前面重复元素的位置**，也就**维护了 `nums[0..slow]` 无重复**；  
（7）循环完后，`slow + 1` 就是长度；

## 【收获 3】

今天输出了篇打卡文章总结：

- [Day04.数组双指针技巧汇总](https://github.com/djsz3y/algorithm-labuladong/blob/master/Day04.%E6%95%B0%E7%BB%84%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB.md)

# 参考链接

- [LABULADONG 的算法网站](https://labuladong.online/algo/)
